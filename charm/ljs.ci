mainmodule miniMD {
  extern module block;
  include "types.h";

  readonly CProxy_Main main_proxy;
  readonly CProxy_KokkosManager kokkos_proxy;
  readonly CProxy_Block block_proxy;
  readonly CProxy_Comm comm_proxy;
  readonly int num_chares;

  readonly std::string input_file;
  readonly int num_threads;
  readonly int teams;
  readonly int num_steps;
  readonly int system_size;
  readonly int nx;
  readonly int ny;
  readonly int nz;
  readonly int ntypes;
  readonly int neighbor_size;
  readonly int halfneigh;
  readonly int team_neigh;
  readonly int use_sse;
  readonly int check_safeexchange;
  readonly int do_safeexchange;
  readonly int sort;
  readonly int yaml_output;
  readonly int yaml_screen;
  readonly int ghost_newton;
  readonly int in_nx;
  readonly int in_ny;
  readonly int in_nz;
  readonly MMD_float in_t_request;
  readonly MMD_float in_rho;
  readonly int in_units;
  readonly ForceStyle in_forcetype;
  readonly MMD_float in_epsilon;
  readonly MMD_float in_sigma;
  readonly std::string in_datafile;
  readonly int in_ntimes;
  readonly MMD_float in_dt;
  readonly int in_neigh_every;
  readonly MMD_float in_force_cut;
  readonly MMD_float in_neigh_cut;
  readonly int in_thermo_nstat;

  mainchare Main {
    entry Main(CkArgMsg* m);
    entry [reductiontarget] void kokkosInitialized();
    entry [reductiontarget] void reduceVelocity(CkReductionMsg* msg);
    entry [reductiontarget] void blockInitialized();
    entry [reductiontarget] void blockDone();
    entry [reductiontarget] void kokkosFinalized();

    entry void run() {
      when kokkosInitialized() serial {
        CkPrintf("[Main] Kokkos initialized\n");
        block_proxy.init();
      }

      when reduceVelocity(CkReductionMsg* msg) serial {
        CkPrintf("[Main] Reducing velocities...\n");
        double vxtot = 0;
        double vytot = 0;
        double vztot = 0;

        CkReduction::setElement* current = (CkReduction::setElement*)msg->getData();
        while (current != NULL) {
          double* result = (double*)&current->data;
          vxtot += result[0];
          vytot += result[1];
          vztot += result[2];
          current = current->next();
        }

        block_proxy.contCreateVelocity(vxtot, vytot, vztot);
      }

      when blockInitialized() serial {
        CkPrintf("[Main] Blocks initialized\n");
        block_proxy.run();
      }

      when blockDone() serial {
        CkPrintf("[Main] Blocks complete\n");
        kokkos_proxy.finalize();
      }

      when kokkosFinalized() serial {
        CkPrintf("[Main] Kokkos finalized\n");
        CkExit();
      }
    }
  };

  nodegroup KokkosManager {
    entry KokkosManager();
    entry void finalize();
  };
};

module block {
  array [1d] Block {
    entry Block();
    entry void init();
    entry void contCreateVelocity(double vxtot, double vytot, double vztot);

    entry [threaded] void run() {
      serial { CkPrintf("Block %d running...\n", thisIndex); }

      serial "preprocess" {
        comm->exchange(atom);
      }

      // Loop over integrate iterations
      for (iter = 0; iter < in_ntimes; iter++) {
      }

      serial "postprocess" {
      }

      serial {
        contribute(CkCallback(CkReductionTarget(Main, blockDone), main_proxy));
      }
    }

    entry void send(int iter, int idim, CkCallback cb) {
      serial {
        thisProxy[comm->chareneigh[idim][0]].recv(iter, (char*)(&(comm->nsend)), sizeof(int));
        if (comm->charegrid[idim] > 2) {
          thisProxy[comm->chareneigh[idim][1]].recv(iter, (char*)(&(comm->nsend)), sizeof(int));
        }
      }

      overlap {
        when recv[iter](int ref, char data[size], size_t size) serial {
          memcpy(&(comm->nrecv1), data, size);
          comm->nrecv = comm->nrecv1;
        }
        if (comm->charegrid[idim] > 2) {
          when recv[iter](int ref, char data[size], size_t size) serial {
            memcpy(&(comm->nrecv2), data, size);
            comm->nrecv += comm->nrecv2;
          }
        }
      }

      serial {
        cb.send();
      }
    }

    entry void recv(int ref, char data[size], size_t size);
  };

  // Bound array to Block
  array [1d] Comm {
    entry Comm();
    /*
    entry void send(int iter, int idim, CkCallback cb) {
      serial {
        thisProxy[chareneigh[idim][0]].recv(iter, nsend, sizeof(int));
        if (charegrid[idim] > 2) {
          thisProxy[chareneigh[idim][1]].recv(iter, nsend, sizeof(int));
        }
      }

      overlap {
        when recv[iter](int ref, char data[size], size_t size) serial {
          memcpy(nrecv1, data, size);
          nrecv = nrecv1;
        }
        if (charegrid[idim] > 2) {
          when recv[iter](int ref, char data[size], size_t size) serial {
            memcpy(nrecv2, data, size);
            nrecv += nrecv2;
          }
        }
      }

      serial {
        cb.send();
      }
    }
    entry void recv(int ref, char data[size], size_t size);
    */
  };
};
